# N-Body Gravitational Simulator

A high-performance N-body gravitational simulator for solar system dynamics, written in C++17. Integrates 35 bodies (the Sun, 8 planets, Pluto, and 25 natural satellites) over multi-century timescales using a 4th-order Yoshida symplectic integrator, validated against NASA JPL Horizons DE441 ephemeris data.

ğŸ“„ **[Technical Paper](docs/N_Body_Technical_Paper.pdf)** â€” Full derivations, validation methodology, and error analysis.

---

## Key Results

**100-year simulation (1950â€“2050), 35 bodies, Î”t = 360 s, Yoshida 4th-order:**

| Metric | Value |
|---|---|
| Mean max relative error | 0.053% |
| Worst-case body | Ganymede (0.290%) |
| Planet error range | 0.0003% â€“ 0.173% |
| Energy conservation Î”E/E | 7.4 Ã— 10â»Â¹Â¹% |
| Wall-clock runtime | 56.5 s (single core) |

**249-year simulation (1950â€“2199):**

| Metric | Value |
|---|---|
| Mean max relative error | 0.115% |
| Worst-case planet | Mercury (0.417%) |
| Energy conservation Î”E/E | 1.0 Ã— 10â»Â¹â°% |
| Wall-clock runtime | 171.6 s |

Residual errors are attributed to physics model differences (Newtonian gravity with 35 bodies vs. JPL DE441's ~300 bodies with post-Newtonian relativity, solar oblateness Jâ‚‚, asteroid perturbations, and tidal effects), not numerical integration error. This is confirmed by the fact that reducing Î”t by 10Ã— improves energy conservation by ~460Ã— while positional errors remain unchanged â€” they have converged to the physics model floor.

---

## Features

- **Yoshida 4th-order symplectic integrator** â€” O(Î”tâ´) accuracy with only 3 force evaluations per step; bounded oscillatory energy error with no secular drift
- **Velocity Verlet** alternative (2nd-order) for comparison
- **Automated JPL Horizons validation pipeline** â€” fetches reference ephemerides and compares against simulation output at epoch-aligned intervals
- **35 solar system bodies** with JPL-sourced initial conditions (auto-generated `Body.hpp`)
- **Structure-of-Arrays (SoA) memory layout** with `__restrict__` annotations for cache performance and SIMD auto-vectorization
- **OpenMP parallelization** â€” automatically enabled for N â‰¥ 500; ~6Ã— speedup on 6 cores at N = 10,000
- **Branchless force computation** â€” floating-point mask eliminates conditional branches in the SIMD-vectorized inner loop
- **Single-file configuration** â€” change `dt`, `num_years`, or `output_hours` in `Config.hpp` and both the C++ simulator and Python tools adapt automatically (with compile-time validation)
- **Interactive 3D visualization** via matplotlib

---

## Quick Start

### Prerequisites

- C++17 compiler (GCC / Clang / MSVC)
- CMake 3.16+
- OpenMP
- Python 3.8+ with `numpy` and `matplotlib`
- Internet connection (for JPL Horizons API)

### Build & Run

```bash
# 1. Fetch JPL reference data and generate Body.hpp
python src/jpl_compare.py fetch --moons

# 2. Build
cmake -B build
cmake --build build

# 3. Run simulation
./build/main

# 4. Validate against JPL Horizons
python src/jpl_compare.py compare

# 5. Visualize
python src/visualize.py
```

---

## Configuration

All simulation parameters live in `src/Config.hpp`:

```cpp
inline static constexpr double dt{ 360.0 };               // Integration timestep (seconds)
inline static constexpr std::size_t num_years{ 249 };     // Simulation duration
inline static constexpr std::size_t output_hours{ 487 };  // Output interval (hours)
```

The Python scripts read `num_years` and `output_hours` directly from this file, so there is a single source of truth. A `static_assert` enforces that `output_hours Ã— 3600` is divisible by `dt`.

---

## Project Structure

```
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp                # Entry point
â”‚   â”œâ”€â”€ Config.hpp              # Single-source configuration (dt, duration, output interval)
â”‚   â”œâ”€â”€ Body.hpp                # JPL Horizons initial conditions (auto-generated by jpl_compare.py)
â”‚   â”œâ”€â”€ Output.hpp              # CSV output handler
â”‚   â”œâ”€â”€ Force/
â”‚   â”‚   â”œâ”€â”€ Force.hpp           # Abstract force interface
â”‚   â”‚   â””â”€â”€ Force.cpp           # Newtonian gravity (O(NÂ²) pairwise, SIMD, branchless)
â”‚   â”œâ”€â”€ Integrator/
â”‚   â”‚   â”œâ”€â”€ Integrator.hpp      # Abstract integrator interface
â”‚   â”‚   â””â”€â”€ Integrator.cpp      # Yoshida 4th-order, Velocity Verlet
â”‚   â”œâ”€â”€ Particle/
â”‚   â”‚   â”œâ”€â”€ Particle.hpp        # SoA particle data structure
â”‚   â”‚   â””â”€â”€ Particle.cpp        # Heap-allocated contiguous arrays
â”‚   â”œâ”€â”€ Simulation/
â”‚   â”‚   â”œâ”€â”€ Simulation.hpp      # Simulation orchestration
â”‚   â”‚   â””â”€â”€ Simulation.cpp      # Time-stepping loop, energy diagnostics
â”‚   â”œâ”€â”€ validation/             # Output directory (gitignored)
â”‚   â”‚   â”œâ”€â”€ sim_output.csv
â”‚   â”‚   â””â”€â”€ jpl_reference.csv
â”‚   â”œâ”€â”€ jpl_compare.py          # JPL fetch + validation pipeline
â”‚   â””â”€â”€ visualize.py            # Interactive 3D orbit viewer
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ N_Body_Technical_Paper.pdf
â””â”€â”€ CMakeLists.txt
```

---

## How It Works

### Yoshida 4th-Order Symplectic Integrator

The integrator composes three leapfrog sub-steps with coefficients chosen to cancel lower-order error terms, achieving O(Î”tâ´) local truncation error. Each timestep consists of four position drifts interleaved with three force evaluations (kicks). The negative intermediate coefficient introduces a backward sub-step â€” counterintuitive, but essential for the error cancellation that yields 4th-order accuracy.

Because the method is symplectic, it exactly preserves a nearby shadow Hamiltonian, guaranteeing that energy errors remain bounded and oscillatory over arbitrarily long integrations. This is what makes multi-century simulations feasible.

### Force Computation

Pairwise Newtonian gravity via O(NÂ²) direct summation. Self-interaction is eliminated with a branchless floating-point mask (`i == j ? 0.0 : 1.0`) rather than a conditional branch, preserving SIMD vectorization of the inner loop. Newton's third law symmetry is intentionally not exploited â€” the doubled FLOP count is traded for regular memory access patterns and freedom from race conditions under thread parallelism.

### Validation Pipeline

`jpl_compare.py` automates the full validation workflow: it queries the JPL Horizons API for state vectors of all 35 bodies at intervals matching the simulation output, then computes per-body position errors at each epoch. Both the simulator and the reference fetch read the same `Config.hpp`, so the comparison is epoch-aligned with no interpolation artifacts.

### Visualization

`visualize.py` provides an interactive 3D matplotlib viewer with keyboard controls: Space (play/pause), arrow keys (step/speed), T (toggle trails), R (reset), Q (quit).

---

## Error Attribution

The error hierarchy matches the expected importance of missing physics:

- **Outer planets** (Saturn, Uranus, Neptune): < 0.001% â€” dominated by solar gravity, minimal missing effects
- **Inner planets** (Venus, Earth, Mars): < 0.06% â€” small contributions from missing asteroids and Jâ‚‚
- **Mercury**: 0.17% (100 yr), 0.42% (249 yr) â€” general relativistic precession of ~43 arcsec/century is the dominant unmodeled effect
- **Galilean moons**: 0.11%â€“0.29% â€” phase drift from fast orbital periods (Io completes ~20,600 orbits in 100 years)
- **Sun**: 1.34% at 249 yr â€” coordinate artifact in the barycentric frame, not a simulation failure (the Sun's barycentric displacement is only ~10â¶ km vs. ~10â¹ km for outer planets)

Post-Newtonian (EIH) corrections were implemented and tested, but the velocity-dependent potential breaks the separability required by the Yoshida integrator, degrading energy conservation by ~4 orders of magnitude. A proper fix requires implicit or mixed-variable symplectic methods.

---

## License

MIT